function [vis, mom, mu, beta] = IsDSwCC(P, rho, M, white_noise)
% function to calculate the amount of noise that makes the behaviour
% P generated by the measurements M and the states rho distributedly
% samplable with classical communication

% inputs:
% rho(d,d,s) : set of s d-dimensional states
% Mby(d,d,o,m) : set of m(=2,3) o-outcome, d-dimensional measurements
% white_noise: 0 or 1, depending whether one whises to check the general
%              robustness of the behaviour (0) or the white-noise
%              robustness (1)

if ~exist('white_noise','var')
    % parameter does not exist, so default it to 0
    white_noise = 0;
end

d = size(rho,1);
s = size(rho,3);
if s ~= size(P,2)
    fprintf('Inconsistent dimensionalities\n')
end
o = size(P,1);
m = size(P,3);

if m == 2 && white_noise == 0
    cvx_begin sdp quiet
        variable mom(d,d,o,o) complex % mother measurement
        variable q(o,s,m) % noise-probabilities
        variable vis(1,1) nonnegative % visibility of the behaviour
        dual variables mu{o,s,m} % coefficients of the dual inequality
        dual variables B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
                % this constraint already ensures the subnormalisation
                % sum(q(:,x,y)) = 1-vis
     mu{b,x,1}: vis*P(b,x,1) + q(b,x,1) == ...
                    trace(rho(:,:,x)*sum(mom(:,:,b,:),4));
                q(b,x,1) >= 0;
     mu{b,x,2}: vis*P(b,x,2) + q(b,x,2) == ...
                    trace(rho(:,:,x)*sum(mom(:,:,:,b),3));
                q(b,x,2) >= 0;
                for j1 = 1:o
                    mom(:,:,b,j1) >= 0;
                end
            end
        end
  B{1}: sum(sum(mom,3),4) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
elseif m == 2 && white_noise == 1
    q = zeros(o,s,m);
    for b  = 1:o
        for x = 1:s
            for y = 1:m
                % q represents white noise
                q(b,x,y) = trace(M(:,:,b,y))/d;
            end
        end
    end
    cvx_begin sdp quiet
        variable mom(d,d,o,o) complex % mother measurement
        variable vis(1,1) nonnegative % visibility of the behaviour
        dual variables mu{o,s,m} % coefficients of the dual inequality
        dual variable B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
     mu{b,x,1}: vis*P(b,x,1) + (1-vis)*q(b,x,1) == ...
                    trace(rho(:,:,x)*sum(mom(:,:,b,:),4));
     mu{b,x,2}: vis*P(b,x,2) + (1-vis)*q(b,x,2) == ...
                    trace(rho(:,:,x)*sum(mom(:,:,:,b),3));
                for j1 = 1:o
                    mom(:,:,b,j1) >= 0;
                end
            end
        end
  B{1}: sum(sum(mom,3),4) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
elseif m == 3 && white_noise == 0
    cvx_begin sdp quiet
        variable mom(d,d,o,o,o) complex % mother measurement
        variable q(o,s,m) % noise-probabilities
        variable vis(1,1) nonnegative % visibility of the behaviour
        dual variables mu{o,s,m} % coefficients of the dual inequality
        dual variables B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
                % this constrain already ensures the subnormalisation
                % sum(q(:,x,y)) = 1-vis
     mu{b,x,1}: vis*P(b,x,1) + q(b,x,1) == ...
                    trace(rho(:,:,x)*sum(sum(mom(:,:,b,:,:),4),5));
                q(b,x,1) >= 0;
     mu{b,x,2}: vis*P(b,x,2) + q(b,x,2) == ...
                    trace(rho(:,:,x)*sum(sum(mom(:,:,:,b,:),3),5));
                q(b,x,2) >= 0;
     mu{b,x,3}: vis*P(b,x,3) + q(b,x,3) == ...
                    trace(rho(:,:,x)*sum(sum(mom(:,:,:,:,b),3),4));
                q(b,x,3) >= 0;
                for j1 = 1:o
                    for j2 = 1:o
                        mom(:,:,b,j1,j2) >= 0;
                    end
                end
            end
        end
  B{1}: sum(sum(sum(mom,3),4),5) == eye(d);
    cvx_end
    vis = cvx_optval;
elseif m == 3 && white_noise == 1
    cvx_begin sdp quiet
        variable mom(d,d,o,o,o) complex % mother measurement
        variable vis(1,1) nonnegative % visibility of the behaviour
        dual variables mu{o,s,m} % coefficients of the dual inequality
        dual variables B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
     mu{b,x,1}: vis*P(b,x,1) + (1 - vis)*trace(M(:,:,b,1))/2 ...
                    == trace(rho(:,:,x)*sum(sum(mom(:,:,b,:,:),4),5));
     mu{b,x,2}: vis*P(b,x,2) + (1 - vis)*trace(M(:,:,b,2))/2 ...
                    == trace(rho(:,:,x)*sum(sum(mom(:,:,:,b,:),3),5));
     mu{b,x,3}: vis*P(b,x,3) + (1 - vis)*trace(M(:,:,b,3))/2 ...
                    == trace(rho(:,:,x)*sum(sum(mom(:,:,:,:,b),3),4));
                for j1 = 1:o
                    for j2 = 1:o
                        mom(:,:,b,j1,j2) >= 0;
                    end
                end
            end
        end
  B{1}: sum(sum(sum(mom,3),4),5) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
else
    fprintf('Too many measurements\n')
end
