function [vis, mom, mu, beta] = IsCCrealisable(P, rho, M, white_noise)
% function to calculate the amount of noise that makes the behaviour
% P generated by the measurements M and the states rho accepting a 
% distributed sampling realisation with classical communication

% arguments:
% P(o, s, m) : behaviour of o-outcomes, constructed from s quantum states
%              and m quantum measurements
% rho(d, d, s) : set of s d-dimensional states
% M(d, d, o, m) : set of m(=2,3) o-outcome, d-dimensional measurements
% white_noise: 0 or 1, depending whether one wishes to check the 
%              behaviour's general robustness (0) or white-noise
%              robustness (1) regarding distributed sampling with classical
%              communication

% argument M is optional

% input white_noise is optional, but if it equals 1, then M must be
% provided or calculated
if ~exist('white_noise','var')
    white_noise = 0;
elseif white_noise == 1 && ~exist('M','var')
    [vis, M, ~, ~] = IsQuantumRealisable(P, rho);
    if abs(vis - 1) > 10e-08
        fprintf('Unphysical behaviour: white noise not defined\n')
    end
end

d = size(rho, 1);
s = size(rho, 3);
if s ~= size(P, 2)
    fprintf('Inconsistent dimensionalities\n')
end
o = size(P, 1);
m = size(P, 3);

if m == 2 && white_noise == 0
    cvx_begin sdp quiet
        variable mom(d, d, o, o) complex % mother measurement
        variable q(o, s, m) % noise-probabilities
        variable vis(1, 1) nonnegative % visibility of the behaviour
        dual variables mu{o, s, m} % coefficients of the dual inequality
        dual variable B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
                % this constraint already ensures the subnormalisation
                % sum(q(:, x, y)) = 1 - vis
     mu{b, x, 1}: vis*P(b, x, 1) + q(b, x, 1) == ...
                    trace(rho(:, :, x)*sum(mom(:, :, b, :), 4));
                q(b, x, 1) >= 0;
     mu{b,x,2}: vis*P(b, x, 2) + q(b, x, 2) == ...
                    trace(rho(:, :, x)*sum(mom(:, :, :, b), 3));
                q(b, x, 2) >= 0;
                for j1 = 1:o
                    mom(:, :, b, j1) >= 0;
                end
            end
        end
  B{1}: sum(sum(mom, 3), 4) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
    mu = cell2mat(mu);
elseif m == 2 && white_noise == 1
    cvx_begin sdp quiet
        variable mom(d, d, o, o) complex % mother measurement
        variable vis(1, 1) nonnegative % visibility of the behaviour
        dual variables mu{o, s, m} % coefficients of the dual inequality
        dual variable B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
     mu{b, x, 1}: vis*P(b, x, 1) + (1 - vis)*trace(M(:, :, b, 1))/2 == ...
                    trace(rho(:, :, x)*sum(mom(:, :, b, :), 4));
     mu{b,x,2}: vis*P(b, x, 2) + (1 - vis)*trace(M(:, :, b, 2))/2 == ...
                    trace(rho(:, :, x)*sum(mom(:, :, :, b), 3));
                for j1 = 1:o
                    mom(:, :, b, j1) >= 0;
                end
            end
        end
  B{1}: sum(sum(mom, 3), 4) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
    mu = cell2mat(mu);
elseif m == 3 && white_noise == 0
    cvx_begin sdp quiet
        variable mom(d, d, o, o, o) complex % mother measurement
        variable q(o, s, m) % noise-probabilities
        variable vis(1, 1) nonnegative % visibility of the behaviour
        dual variables mu{o, s, m} % coefficients of the dual inequality
        dual variable B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
                % this constrain already ensures the subnormalisation
                % sum(q(:, x, y)) = 1 - vis
     mu{b, x, 1}: vis*P(b, x, 1) + q(b, x, 1) == ...
                    trace(rho(:, :, x)*sum(sum(mom(:, :, b, :, :), 4), 5));
                q(b, x, 1) >= 0;
     mu{b, x, 2}: vis*P(b, x, 2) + q(b, x, 2) == ...
                    trace(rho(:, :, x)*sum(sum(mom(:, :, :, b, :), 3), 5));
                q(b, x, 2) >= 0;
     mu{b, x, 3}: vis*P(b, x, 3) + q(b, x, 3) == ...
                    trace(rho(:, :, x)*sum(sum(mom(:, :, :, :, b), 3), 4));
                q(b, x, 3) >= 0;
                for j1 = 1:o
                    for j2 = 1:o
                        mom(:, :, b, j1, j2) >= 0;
                    end
                end
            end
        end
  B{1}: sum(sum(sum(mom, 3), 4), 5) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
    mu = cell2mat(mu);
elseif m == 3 && white_noise == 1
    cvx_begin sdp quiet
        variable mom(d, d, o, o, o) complex % mother measurement
        variable vis(1, 1) nonnegative % visibility of the behaviour
        dual variables mu{o, s, m} % coefficients of the dual inequality
        dual variable B{1} % provides the bound for the dual inequality
        maximise vis
        for b = 1:o
            for x = 1:s
     mu{b, x, 1}: vis*P(b, x, 1) + (1 - vis)*trace(M(:, :, b, 1))/2 ...
                    == trace(rho(:, :, x)*sum(sum(mom(:, :, b, :, :), 4), 5));
     mu{b, x, 2}: vis*P(b, x, 2) + (1 - vis)*trace(M(:, :, b, 2))/2 ...
                    == trace(rho(:, :, x)*sum(sum(mom(:, :, :, b, :), 3), 5));
     mu{b, x, 3}: vis*P(b, x, 3) + (1 - vis)*trace(M(:, :, b, 3))/2 ...
                    == trace(rho(:, :, x)*sum(sum(mom(:, :, :, :, b), 3), 4));
                for j1 = 1:o
                    for j2 = 1:o
                        mom(:, :, b, j1, j2) >= 0;
                    end
                end
            end
        end
  B{1}: sum(sum(sum(mom, 3), 4), 5) == eye(d);
    cvx_end
    vis = cvx_optval;
    beta = trace(B{1});
    mu = cell2mat(mu);
else
    fprintf('Too many measurements\n')
end
